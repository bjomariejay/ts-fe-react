


-------------------------------------------------------------
to login user ( create login page > create hooks useAuth > create api auth.api )
-------------------------------------------------------------

1. create the login page first `src/pages/LoginPage.tsx`

        import { FormEvent, useState } from "react";

        interface LoginPageProps {
          onLogin: (username: string, password: string) => Promise<void>;
        }

        const LoginPage = ({ onLogin }: LoginPageProps) => {
          const [username, setUsername] = useState("");
          const [password, setPassword] = useState("");

          const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
            event.preventDefault();
            await onLogin(username, password);
          };

          return (
            <form onSubmit={handleSubmit}>
              <label>
                Username
                <input value={username} onChange={e => setUsername(e.target.value)} />
              </label>
              <label>
                Password
                <input type="password" value={password} onChange={e => setPassword(e.target.value)} />
              </label>
              <button type="submit">Login</button>
            </form>
          );
        };

        export default LoginPage;

   The production component in this project adds styles, error handling, loading state, and a “Create user” CTA, but start with the simple username/password/login button flow above.

2. after the UI exists, build the auth hook `src/hooks/useAuth.ts`

        import { useState } from "react";
        import { login as loginRequest } from "../api/auth.api";
        import { AuthenticatedUser } from "../types/auth";

        export const useAuth = () => {
          const [user, setUser] = useState<AuthenticatedUser | null>(null);
          const [error, setError] = useState("");
          const [isLoading, setIsLoading] = useState(false);

          const login = async (username: string, password: string) => {
            setIsLoading(true);
            setError("");
            try {
              const response = await loginRequest({ username, password });
              if (response.success && response.user) {
                setUser(response.user);
                return { success: true };
              }
              setError(response.message ?? "Unable to login");
              return { success: false };
            } catch {
              setError("Login failed. Please try again.");
              return { success: false };
            } finally {
              setIsLoading(false);
            }
          };

          const logout = () => setUser(null);
          const clearError = () => setError("");

          return { user, login, logout, error, clearError, isLoading };
        };

3. lastly, hook the API transport `src/api/auth.api.ts`

        import axios from "axios";

        const API_URL = "http://localhost:5000/api";

        export interface LoginPayload {
          username: string;
          password: string;
        }

        export interface LoginResponse {
          success: boolean;
          user?: {
            id: number;
            name: string;
            age: number;
            address: string;
            username: string;
          };
          message?: string;
        }

        export const login = async (payload: LoginPayload) => {
          const response = await axios.post<LoginResponse>(`${API_URL}/login`, payload);
          return response.data;
        };



-------------------------------------------------------------
to create user with crud function ( add create user page > create hooks useUsers.ts > create api user.api )
-------------------------------------------------------------
1. add the Create User page first `src/pages/ManageUsersPage.tsx`

        import { useUsers } from "../hooks/useUsers";

        const ManageUsersPage = ({ onBackToLogin }: { onBackToLogin: () => void }) => {
          const {
            users,
            form,
            editingId,
            isLoadingUsers,
            isSubmitting,
            error,
            statusMessage,
            handleFieldChange,
            handleSubmit,
            handleEdit,
            handleDelete,
            resetForm,
          } = useUsers();

          return (
            <div>
              <form onSubmit={handleSubmit}>
                <input value={form.name} onChange={e => handleFieldChange("name", e.target.value)} />
                <input value={form.age} onChange={e => handleFieldChange("age", e.target.value)} />
                <input value={form.address} onChange={e => handleFieldChange("address", e.target.value)} />
                <input value={form.username} onChange={e => handleFieldChange("username", e.target.value)} />
                <input type="password" value={form.password} onChange={e => handleFieldChange("password", e.target.value)} />
                <button type="submit">{editingId ? "Update" : "Create"} User</button>
                {editingId && <button onClick={resetForm}>Cancel edit</button>}
              </form>

              <table>
                <thead>
                  <tr>
                    <th>Name</th>
                    <th>Username</th>
                    <th>Age</th>
                    <th>Address</th>
                    <th>Actions</th>
                  </tr>
                </thead>
                <tbody>
                  {users.map(user => (
                    <tr key={user.id}>
                      <td>{user.name}</td>
                      <td>{user.username}</td>
                      <td>{user.age}</td>
                      <td>{user.address}</td>
                      <td>
                        <button onClick={() => handleEdit(user)}>Edit</button>
                        <button onClick={() => handleDelete(user.id)}>Delete</button>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          );
        };

   Style it to match your app, but start with the basic form + table layout above.

2. move all CRUD state/logic into `src/hooks/useUsers.ts`

        import { FormEvent, useEffect, useState } from "react";
        import { createUser, deleteUser, getUsers, updateUser } from "../api/user.api";
        import { AppUser } from "../types/user";

        export const useUsers = () => {
          const [users, setUsers] = useState<AppUser[]>([]);
          const [form, setForm] = useState({ name: "", age: "", address: "", username: "", password: "" });
          const [editingId, setEditingId] = useState<number | null>(null);
          const [isLoadingUsers, setIsLoadingUsers] = useState(true);
          const [isSubmitting, setIsSubmitting] = useState(false);
          const [error, setError] = useState("");
          const [statusMessage, setStatusMessage] = useState("");

          useEffect(() => {
            getUsers().then(setUsers).catch(() => setError("Unable to load users")).finally(() => setIsLoadingUsers(false));
          }, []);

          const handleFieldChange = (field: keyof typeof form, value: string) => {
            setForm(prev => ({ ...prev, [field]: value }));
            setError("");
            setStatusMessage("");
          };

          const handleSubmit = async (event: FormEvent<HTMLFormElement>) => {
            event.preventDefault();

            const trimmedName = form.name.trim();
            const trimmedAddress = form.address.trim();
            const trimmedUsername = form.username.trim();
            const numericAge = Number(form.age);

            if (!trimmedName || !trimmedAddress || !trimmedUsername || !Number.isFinite(numericAge)) {
              setError("Name, age, address, and username are required. Age must be a number.");
              return;
            }

            if (!editingId && !form.password) {
              setError("Password is required when creating a user.");
              return;
            }

            setIsSubmitting(true);
            setError("");

            try {
              if (editingId) {
                const updatedUser = await updateUser(editingId, {
                  name: trimmedName,
                  age: numericAge,
                  address: trimmedAddress,
                  username: trimmedUsername,
                  password: form.password || undefined,
                });
                setUsers(prev => prev.map(user => (user.id === editingId ? updatedUser : user)));
                setStatusMessage("User updated successfully.");
              } else {
                const newUser = await createUser({
                  name: trimmedName,
                  age: numericAge,
                  address: trimmedAddress,
                  username: trimmedUsername,
                  password: form.password,
                });
                setUsers(prev => [...prev, newUser]);
                setStatusMessage("User created successfully. You can now sign in with this account.");
              }

              resetForm();
            } catch (err) {
              setError("Action failed. Please try again.");
            } finally {
              setIsSubmitting(false);
            }
          };

          const handleEdit = (user: AppUser) => {
            setEditingId(user.id);
            setForm({ name: user.name, age: String(user.age), address: user.address, username: user.username, password: "" });
          };

          const handleDelete = async (id: number) => {
            await deleteUser(id);
            setUsers(prev => prev.filter(user => user.id !== id));
          };

          const resetForm = () => {
            setForm({ name: "", age: "", address: "", username: "", password: "" });
            setEditingId(null);
          };

          return {
            users,
            form,
            editingId,
            isLoadingUsers,
            isSubmitting,
            error,
            statusMessage,
            handleFieldChange,
            handleSubmit,
            handleEdit,
            handleDelete,
            resetForm,
          };
        };

   Flesh out `handleSubmit` with the validation/CRUD logic from the source hook so your component can stay purely presentational.

3. connect the REST layer using `src/api/user.api.ts`

        import axios from "axios";
        import { AppUser, CreateUserPayload, UpdateUserPayload } from "../types/user";

        const API_URL = "http://localhost:5000/api";

        export const getUsers = async (): Promise<AppUser[]> => {
          const res = await axios.get<AppUser[]>(`${API_URL}/users`);
          return res.data;
        };

        export const createUser = async (user: CreateUserPayload): Promise<AppUser> => {
          const res = await axios.post<AppUser>(`${API_URL}/users`, user);
          return res.data;
        };

        export const updateUser = async (id: number, data: UpdateUserPayload): Promise<AppUser> => {
          const res = await axios.put<AppUser>(`${API_URL}/users/${id}`, data);
          return res.data;
        };

        export const deleteUser = async (id: number): Promise<void> => {
          await axios.delete(`${API_URL}/users/${id}`);
        };


-------------------------------------------------------------
Protected routes + API tokens with JWT  (what changed)
-------------------------------------------------------------

0. New dependencies
       - Installed `react-router-dom` + `@types/react-router-dom` for client routing/protected routes.
       - Added a shared Axios instance to inject the JWT automatically.

1. Token storage helper (`src/utils/authStorage.ts`)
       - Wrapper around `localStorage` so we can persist / clear the token.
       ```ts
       const TOKEN_STORAGE_KEY = "auth_token";
       export const getStoredToken = () => localStorage.getItem(TOKEN_STORAGE_KEY);
       export const persistToken = (token: string) => localStorage.setItem(TOKEN_STORAGE_KEY, token);
       export const clearStoredToken = () => localStorage.removeItem(TOKEN_STORAGE_KEY);
       ```

2. Axios client with interceptors (`src/api/httpClient.ts`)
       - Reads the stored token and attaches `Authorization: Bearer ...` on every request.
       - Listens for 401 responses, clears storage, and emits a `window` event so the UI can log the user out.
       ```ts
       import axios, { AxiosHeaders } from "axios";
       import { clearStoredToken, getStoredToken } from "../utils/authStorage";

       export const httpClient = axios.create({ baseURL: process.env.REACT_APP_API_URL ?? "http://localhost:5000/api" });

       httpClient.interceptors.request.use(config => {
         const token = getStoredToken();
         if (token) {
           config.headers = AxiosHeaders.from(config.headers || {});
           config.headers.set("Authorization", `Bearer ${token}`);
         }
         return config;
       });

       httpClient.interceptors.response.use(
         response => response,
         error => {
           if (error?.response?.status === 401) {
             clearStoredToken();
             window.dispatchEvent(new Event("auth:unauthorized"));
           }
           return Promise.reject(error);
         }
       );
       ```

3. Auth hook + context (`src/hooks/useAuth.ts` + `src/context/AuthContext.tsx`)
       - `useAuth` persists the token on login, restores the session on load via `/api/me`, and clears everything on logout/401.
       - `AuthProvider` exposes the hook through React context so any component can check `user` state.
       ```ts
       const login = async (username: string, password: string) => {
         const response = await loginRequest({ username, password });
         if (response.success && response.user && response.token) {
           persistToken(response.token);
           setUser(response.user);
         }
       };

       useEffect(() => {
         const restoreSession = async () => {
           const token = getStoredToken();
           if (!token) return setIsBootstrapping(false);
           try {
             const response = await getCurrentUser();
             response.success && response.user ? setUser(response.user) : clearStoredToken();
           } finally {
             setIsBootstrapping(false);
           }
         };
         restoreSession();
       }, []);
       ```

4. Routing + protected UI (`src/App.tsx`, `src/components/ProtectedRoute.tsx`, `src/pages/SignupPage.tsx`, `src/pages/ManageUsersPage.tsx`)
       - Swapped to `react-router-dom` so `/login`, `/signup`, `/dashboard`, `/manage-users` are real routes.
       - `ProtectedRoute` gates dashboard/admin pages until the auth hook finishes bootstrapping and confirms a user.
       - Signup page logs the token to `console` for debugging.
       ```tsx
       <Routes>
         <Route path="/login" element={user ? <Navigate to="/dashboard" /> : <LoginPage ... />} />
         <Route path="/signup" element={user ? <Navigate to="/dashboard" /> : <SignupPage />} />
         <Route path="/dashboard" element={
           <ProtectedRoute>
             <DashboardPage ... />
           </ProtectedRoute>
         } />
         <Route path="/manage-users" element={
           <ProtectedRoute>
             <ManageUsersPage ... />
           </ProtectedRoute>
         } />
       </Routes>
       ```

Result: once you log in or sign up, the frontend stores the JWT, injects it into every API call, auto-logs out on 401, and prevents navigating to protected screens until a valid token/user is present.
